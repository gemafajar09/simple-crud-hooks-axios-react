{"ast":null,"code":"var url = require(\"url\");\n\nvar http = require(\"http\");\n\nvar https = require(\"https\");\n\nvar assert = require(\"assert\");\n\nvar Writable = require(\"stream\").Writable;\n\nvar debug = require(\"debug\")(\"follow-redirects\"); // RFC7231§4.2.1: Of the request methods defined by this specification,\n// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.\n\n\nvar SAFE_METHODS = {\n  GET: true,\n  HEAD: true,\n  OPTIONS: true,\n  TRACE: true\n}; // Create handlers that pass events from native requests\n\nvar eventHandlers = Object.create(null);\n[\"abort\", \"aborted\", \"error\", \"socket\", \"timeout\"].forEach(function (event) {\n  eventHandlers[event] = function (arg) {\n    this._redirectable.emit(event, arg);\n  };\n}); // An HTTP(S) request that can be redirected\n\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  options.headers = options.headers || {};\n  this._options = options;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = []; // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n\n    delete options.host;\n  } // Attach a callback if passed\n\n\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  } // React to responses of native requests\n\n\n  var self = this;\n\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  }; // Complete the URL object when necessary\n\n\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    } else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  } // Perform the first request\n\n\n  this._performRequest();\n}\n\nRedirectableRequest.prototype = Object.create(Writable.prototype); // Writes buffered data to the current native request\n\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && \"length\" in data)) {\n    throw new Error(\"data should be a string, Buffer or Uint8Array\");\n  }\n\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  } // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n\n\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n\n    return;\n  } // Only write when we don't exceed the maximum body length\n\n\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n\n    this._requestBodyBuffers.push({\n      data: data,\n      encoding: encoding\n    });\n\n    this._currentRequest.write(data, encoding, callback);\n  } // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new Error(\"Request body larger than maxBodyLength limit\"));\n    this.abort();\n  }\n}; // Ends the current native request\n\n\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  } else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  } // Write data and end\n\n\n  var currentRequest = this._currentRequest;\n  this.write(data || \"\", encoding, function () {\n    currentRequest.end(null, null, callback);\n  });\n}; // Sets a header value on the current native request\n\n\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n\n  this._currentRequest.setHeader(name, value);\n}; // Clears a header value on the current native request\n\n\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n\n  this._currentRequest.removeHeader(name);\n}; // Proxy all other public ClientRequest methods\n\n\n[\"abort\", \"flushHeaders\", \"getHeader\", \"setNoDelay\", \"setSocketKeepAlive\", \"setTimeout\"].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n}); // Proxy all public ClientRequest properties\n\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () {\n      return this._currentRequest[property];\n    }\n  });\n}); // Executes the next native request (initial or redirect)\n\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n\n  if (!nativeProtocol) {\n    this.emit(\"error\", new Error(\"Unsupported protocol \" + protocol));\n    return;\n  } // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n\n\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  } // Create the native request\n\n\n  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options); // Set up event handlers\n\n  request._redirectable = this;\n\n  for (var event in eventHandlers) {\n    /* istanbul ignore else */\n    if (event) {\n      request.on(event, eventHandlers[event]);\n    }\n  } // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n\n\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var buffers = this._requestBodyBuffers;\n\n    (function writeNext() {\n      if (i < buffers.length) {\n        var buffer = buffers[i++];\n        request.write(buffer.data, buffer.encoding, writeNext);\n      } else {\n        request.end();\n      }\n    })();\n  }\n}; // Processes a response from the current native request\n\n\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: response.statusCode\n    });\n  } // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n\n\n  var location = response.headers.location;\n\n  if (location && this._options.followRedirects !== false && response.statusCode >= 300 && response.statusCode < 400) {\n    // RFC7231§6.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new Error(\"Max redirects exceeded.\"));\n      return;\n    } // RFC7231§6.4: Automatic redirection needs to done with\n    // care for methods not known to be safe […],\n    // since the user might not wish to redirect an unsafe request.\n    // RFC7231§6.4.7: The 307 (Temporary Redirect) status code indicates\n    // that the target resource resides temporarily under a different URI\n    // and the user agent MUST NOT change the request method\n    // if it performs an automatic redirection to that URI.\n\n\n    var header;\n    var headers = this._options.headers;\n\n    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {\n      this._options.method = \"GET\"; // Drop a possible entity and headers related to it\n\n      this._requestBodyBuffers = [];\n\n      for (header in headers) {\n        if (/^content-/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    } // Drop the Host header, as the redirect might lead to a different host\n\n\n    if (!this._isRedirect) {\n      for (header in headers) {\n        if (/^host$/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    } // Perform the redirected request\n\n\n    var redirectUrl = url.resolve(this._currentUrl, location);\n    debug(\"redirecting to\", redirectUrl);\n    Object.assign(this._options, url.parse(redirectUrl));\n    this._isRedirect = true;\n\n    this._performRequest(); // Discard the remainder of the response to avoid waiting for data\n\n\n    response.destroy();\n  } else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response); // Clean up\n\n    this._requestBodyBuffers = [];\n  }\n}; // Wraps the key/value object of protocols with redirect functionality\n\n\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024\n  }; // Wrap each protocol\n\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol); // Executes a request, following redirects\n\n    wrappedProtocol.request = function (options, callback) {\n      if (typeof options === \"string\") {\n        options = url.parse(options);\n        options.maxRedirects = exports.maxRedirects;\n      } else {\n        options = Object.assign({\n          protocol: protocol,\n          maxRedirects: exports.maxRedirects,\n          maxBodyLength: exports.maxBodyLength\n        }, options);\n      }\n\n      options.nativeProtocols = nativeProtocols;\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    }; // Executes a GET request, following redirects\n\n\n    wrappedProtocol.get = function (options, callback) {\n      var request = wrappedProtocol.request(options, callback);\n      request.end();\n      return request;\n    };\n  });\n  return exports;\n} // Exports\n\n\nmodule.exports = wrap({\n  http: http,\n  https: https\n});\nmodule.exports.wrap = wrap;","map":{"version":3,"names":["url","require","http","https","assert","Writable","debug","SAFE_METHODS","GET","HEAD","OPTIONS","TRACE","eventHandlers","Object","create","forEach","event","arg","_redirectable","emit","RedirectableRequest","options","responseCallback","call","headers","_options","_redirectCount","_redirects","_requestBodyLength","_requestBodyBuffers","host","hostname","on","self","_onNativeResponse","response","_processResponse","pathname","path","searchPos","indexOf","substring","search","_performRequest","prototype","write","data","encoding","callback","Error","length","maxBodyLength","push","_currentRequest","abort","end","currentRequest","setHeader","name","value","removeHeader","method","a","b","property","defineProperty","get","protocol","nativeProtocol","nativeProtocols","agents","scheme","substr","agent","request","_currentUrl","format","_isRedirect","i","buffers","writeNext","buffer","trackRedirects","statusCode","location","followRedirects","maxRedirects","header","test","redirectUrl","resolve","assign","parse","destroy","responseUrl","redirects","wrap","protocols","exports","keys","wrappedProtocol","equal","module"],"sources":["D:/react/axios-react-crud/node_modules/axios/node_modules/follow-redirects/index.js"],"sourcesContent":["var url = require(\"url\");\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar assert = require(\"assert\");\nvar Writable = require(\"stream\").Writable;\nvar debug = require(\"debug\")(\"follow-redirects\");\n\n// RFC7231§4.2.1: Of the request methods defined by this specification,\n// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.\nvar SAFE_METHODS = { GET: true, HEAD: true, OPTIONS: true, TRACE: true };\n\n// Create handlers that pass events from native requests\nvar eventHandlers = Object.create(null);\n[\"abort\", \"aborted\", \"error\", \"socket\", \"timeout\"].forEach(function (event) {\n  eventHandlers[event] = function (arg) {\n    this._redirectable.emit(event, arg);\n  };\n});\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  options.headers = options.headers || {};\n  this._options = options;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\n    throw new Error(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new Error(\"Request body larger than maxBodyLength limit\"));\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data and end\n  var currentRequest = this._currentRequest;\n  this.write(data || \"\", encoding, function () {\n    currentRequest.end(null, null, callback);\n  });\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"abort\", \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\", \"setTimeout\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    this.emit(\"error\", new Error(\"Unsupported protocol \" + protocol));\n    return;\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var event in eventHandlers) {\n    /* istanbul ignore else */\n    if (event) {\n      request.on(event, eventHandlers[event]);\n    }\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext() {\n      if (i < buffers.length) {\n        var buffer = buffers[i++];\n        request.write(buffer.data, buffer.encoding, writeNext);\n      }\n      else {\n        request.end();\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: response.statusCode,\n    });\n  }\n\n  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  var location = response.headers.location;\n  if (location && this._options.followRedirects !== false &&\n      response.statusCode >= 300 && response.statusCode < 400) {\n    // RFC7231§6.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new Error(\"Max redirects exceeded.\"));\n      return;\n    }\n\n    // RFC7231§6.4: Automatic redirection needs to done with\n    // care for methods not known to be safe […],\n    // since the user might not wish to redirect an unsafe request.\n    // RFC7231§6.4.7: The 307 (Temporary Redirect) status code indicates\n    // that the target resource resides temporarily under a different URI\n    // and the user agent MUST NOT change the request method\n    // if it performs an automatic redirection to that URI.\n    var header;\n    var headers = this._options.headers;\n    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {\n      this._options.method = \"GET\";\n      // Drop a possible entity and headers related to it\n      this._requestBodyBuffers = [];\n      for (header in headers) {\n        if (/^content-/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Drop the Host header, as the redirect might lead to a different host\n    if (!this._isRedirect) {\n      for (header in headers) {\n        if (/^host$/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Perform the redirected request\n    var redirectUrl = url.resolve(this._currentUrl, location);\n    debug(\"redirecting to\", redirectUrl);\n    Object.assign(this._options, url.parse(redirectUrl));\n    this._isRedirect = true;\n    this._performRequest();\n\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n  }\n  else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    wrappedProtocol.request = function (options, callback) {\n      if (typeof options === \"string\") {\n        options = url.parse(options);\n        options.maxRedirects = exports.maxRedirects;\n      }\n      else {\n        options = Object.assign({\n          protocol: protocol,\n          maxRedirects: exports.maxRedirects,\n          maxBodyLength: exports.maxBodyLength,\n        }, options);\n      }\n      options.nativeProtocols = nativeProtocols;\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    };\n\n    // Executes a GET request, following redirects\n    wrappedProtocol.get = function (options, callback) {\n      var request = wrappedProtocol.request(options, callback);\n      request.end();\n      return request;\n    };\n  });\n  return exports;\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}